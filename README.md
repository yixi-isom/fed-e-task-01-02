# fed-e-task-01-02

简答题

一、请说出下列最终的执行结果并解释为什么。

<!--
var a = [];
for (var i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6]();
-->

10。因为全局变量 i 在循环结束后变为 10.这时候调用 a[6]()则打印此时为 10 的 i。

二、请说出下列最终的执行结果并解释为什么。

<!--
var tmp = 123;
if (true) {
  console.log(tmp);
  let tmp;
}
-->

会报错，因为 if 里的 tmp 没有被 initialize 就被使用了，而 let 不能变量提升，所以会出现 ReferenceError。

三、结合 ES6 新语法，用最简单的方式找出数组中的最小值。

<!-- var arr = [12, 34, 32, 89, 4] -->

Math.min(...arr)

四、请详细说明 var，let 和 const 三种声明变量的方式之间的具体差别。
var 是全局作用域，let 和 const 是 es2015 新出的块级作用域。var 可以变量提升而 let 和 const 不可以，会报错。var 和 let 都是变量，声明和赋值后可以改变值。const 是恒量，具有只读的特性，声明过后不能再重新指向新的内存地址，并且在声明的时候必须赋值。

五、请说出下列代码最终输出的结果并解释为什么。

<!--
var a = 10;
var obj = {
  a: 20,
  fn() {
    setTimeout(() => {
      console.log(this.a);
    });
  },
};
obj.fn();
-->

20。因为 setTimeout 的回调是一个箭头函数，箭头函数的 this 会沿着作用域往上找第一个 function，因为 obj 调用了 fn，所以 this 指向的是 obj，因此 a 为 obj 的 a 值为 20.

六、简述 Symbol 类型的用途。

1. 用来表示一个独一无二的值。最大的特点就是通过 symbol 创建的值都是唯一的，永远不会重复。可以传入一个字符串作为 symbol 的描述文本，多次使用 Symbol 的时候就可以区分出来是哪一个对应的 Symbol。
2. 对象也可以直接使用 Symbol 作为独一无二的属性名，从而避免属性名重复的问题。这是最主要的作用。
3. 可以用来定义私有成员。

七、什么是浅拷贝？什么是深拷贝？
浅拷贝指的是只拷贝了内存地址但是指向的是同一个内存地址，比如 a 和 b 指向了同一个内存地址修改 a 的时候就会修改 b。浅拷贝一般可以用 Object.assign()或是展开运算符...进行操作。
深拷贝则是复制并创建一个一模一样的对象，不共享内存，修改新对象的时候也不会修改到旧对象。深拷贝可以用递归来实现每一层都重新创建对象并复制，或是使用 JSON 的 parse 和 stringify 实现，但是不支持 undefined、函数和 symbol 值。

八、请简述 TypeScript 和 JavaScript 之间的关系。
TypeScript 是 JavaScript 的超集（superset）。在 JavaScript 的基础上多了一些扩展特性，多出来的就是类型系统和对 ES6 新特性的支持。TypeScript 最终会被编译成 JavaScript。

九、请谈谈你所认为的 TypeScript 的优缺点。
优点：

1. 强大的类型系统，可以避免类型异常，提高代码可靠程度。
2. 任何一种 JS 的运行环境都支持。
3. 功能更强大，生态也更健全更完善。
   缺点：
4. 语言本身多了很多概念，接口枚举泛型，提高学习成本。
5. 周期比较短的小型项目会增加成本，开头有很多类型需要编写。

十、描述引用计数的工作原理和优缺点。
引用计数工作原理：在内部通过一个引用计数器设置一个引用数，判断该对象当前引用数是否为 0 来决定是否是一个垃圾对象。如果为 0，GC 就会立即将对象空间进行回收再使用。引用计数器会在引用关系改变时修改引用数字。
优点：

1. 发现垃圾时立即回收
2. 最大限度减少程序暂停
   缺点：
3. 无法回收循环引用的对象
4. 相对于其他 GC 算法，时间开销大

十一、描述标记整理算法的工作流程
首先是标记阶段，会遍历所有对象，将当前的可达活动对象进行标记。在清除阶段会先执行整理，移动对象位置，让地址上产生连续，再将右侧进行回收。配合标记清除可以在 v8 引擎中实现频繁的 GC 操作。

十二、描述 V8 中新生代存储区垃圾回收的流程
新生代指的是存活时间较短的对象，比如局部作用域的变量。新生代存储区垃圾回收采用复制算法+标记整理。新生代内存区分为两个等大小的空间，使用空间为 from，空闲空间为 to。代码在执行时如果需要申请空间进行使用，首先会将所有变量对象都分配至 from 空间，应用到一定程度之后，就会触发 gc 操作，采用标记整理（变为连续地址）后将活动对象拷贝至 to 空间。from 空间做回收操作进行释放。

十三、描述增量标记算法在何时使用及工作原理
实现老生代对象回收的时候我们会使用增量标记算法进行效率优化。将当前一整段的垃圾回收操作拆分成多个小部分组合着完成整个回收，从而替代一口气做完的垃圾回收。好处是可以实现垃圾回收和程序执行交替完成，这样带来的时间消耗会更合理。
